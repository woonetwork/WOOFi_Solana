/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/kinobi-so/kinobi
 */

import {
  Account,
  Context,
  Option,
  OptionOrNullable,
  Pda,
  PublicKey,
  RpcAccount,
  RpcGetAccountOptions,
  RpcGetAccountsOptions,
  assertAccountExists,
  defaultPublicKey,
  deserializeAccount,
  gpaBuilder,
  publicKey as toPublicKey,
} from '@metaplex-foundation/umi';
import {
  Serializer,
  bool,
  bytes,
  mapSerializer,
  option,
  publicKey as publicKeySerializer,
  struct,
  u16,
  u64,
  u8,
} from '@metaplex-foundation/umi/serializers';
import { OFTType, OFTTypeArgs, getOFTTypeSerializer } from '../types';

export type OFTStore = Account<OFTStoreAccountData>;

export type OFTStoreAccountData = {
  discriminator: Uint8Array;
  oftType: OFTType;
  ld2sdRate: bigint;
  tokenMint: PublicKey;
  tokenEscrow: PublicKey;
  endpointProgram: PublicKey;
  bump: number;
  tvlLd: bigint;
  admin: PublicKey;
  defaultFeeBps: number;
  paused: boolean;
  pauser: Option<PublicKey>;
  unpauser: Option<PublicKey>;
};

export type OFTStoreAccountDataArgs = {
  oftType: OFTTypeArgs;
  ld2sdRate: number | bigint;
  tokenMint: PublicKey;
  tokenEscrow: PublicKey;
  endpointProgram: PublicKey;
  bump: number;
  tvlLd: number | bigint;
  admin: PublicKey;
  defaultFeeBps: number;
  paused: boolean;
  pauser: OptionOrNullable<PublicKey>;
  unpauser: OptionOrNullable<PublicKey>;
};

export function getOFTStoreAccountDataSerializer(): Serializer<
  OFTStoreAccountDataArgs,
  OFTStoreAccountData
> {
  return mapSerializer<OFTStoreAccountDataArgs, any, OFTStoreAccountData>(
    struct<OFTStoreAccountData>(
      [
        ['discriminator', bytes({ size: 8 })],
        ['oftType', getOFTTypeSerializer()],
        ['ld2sdRate', u64()],
        ['tokenMint', publicKeySerializer()],
        ['tokenEscrow', publicKeySerializer()],
        ['endpointProgram', publicKeySerializer()],
        ['bump', u8()],
        ['tvlLd', u64()],
        ['admin', publicKeySerializer()],
        ['defaultFeeBps', u16()],
        ['paused', bool()],
        ['pauser', option(publicKeySerializer())],
        ['unpauser', option(publicKeySerializer())],
      ],
      { description: 'OFTStoreAccountData' }
    ),
    (value) => ({
      ...value,
      discriminator: new Uint8Array([195, 215, 104, 134, 185, 195, 240, 114]),
    })
  ) as Serializer<OFTStoreAccountDataArgs, OFTStoreAccountData>;
}

export function deserializeOFTStore(rawAccount: RpcAccount): OFTStore {
  return deserializeAccount(rawAccount, getOFTStoreAccountDataSerializer());
}

export async function fetchOFTStore(
  context: Pick<Context, 'rpc'>,
  publicKey: PublicKey | Pda,
  options?: RpcGetAccountOptions
): Promise<OFTStore> {
  const maybeAccount = await context.rpc.getAccount(
    toPublicKey(publicKey, false),
    options
  );
  assertAccountExists(maybeAccount, 'OFTStore');
  return deserializeOFTStore(maybeAccount);
}

export async function safeFetchOFTStore(
  context: Pick<Context, 'rpc'>,
  publicKey: PublicKey | Pda,
  options?: RpcGetAccountOptions
): Promise<OFTStore | null> {
  const maybeAccount = await context.rpc.getAccount(
    toPublicKey(publicKey, false),
    options
  );
  return maybeAccount.exists ? deserializeOFTStore(maybeAccount) : null;
}

export async function fetchAllOFTStore(
  context: Pick<Context, 'rpc'>,
  publicKeys: Array<PublicKey | Pda>,
  options?: RpcGetAccountsOptions
): Promise<OFTStore[]> {
  const maybeAccounts = await context.rpc.getAccounts(
    publicKeys.map((key) => toPublicKey(key, false)),
    options
  );
  return maybeAccounts.map((maybeAccount) => {
    assertAccountExists(maybeAccount, 'OFTStore');
    return deserializeOFTStore(maybeAccount);
  });
}

export async function safeFetchAllOFTStore(
  context: Pick<Context, 'rpc'>,
  publicKeys: Array<PublicKey | Pda>,
  options?: RpcGetAccountsOptions
): Promise<OFTStore[]> {
  const maybeAccounts = await context.rpc.getAccounts(
    publicKeys.map((key) => toPublicKey(key, false)),
    options
  );
  return maybeAccounts
    .filter((maybeAccount) => maybeAccount.exists)
    .map((maybeAccount) => deserializeOFTStore(maybeAccount as RpcAccount));
}

export function getOFTStoreGpaBuilder(
  context: Pick<Context, 'rpc' | 'programs'>
) {
  const programId = context.programs.getPublicKey('oft', defaultPublicKey(), 'custom')
  return gpaBuilder(context, programId)
    .registerFields<{
      discriminator: Uint8Array;
      oftType: OFTTypeArgs;
      ld2sdRate: number | bigint;
      tokenMint: PublicKey;
      tokenEscrow: PublicKey;
      endpointProgram: PublicKey;
      bump: number;
      tvlLd: number | bigint;
      admin: PublicKey;
      defaultFeeBps: number;
      paused: boolean;
      pauser: OptionOrNullable<PublicKey>;
      unpauser: OptionOrNullable<PublicKey>;
    }>({
      discriminator: [0, bytes({ size: 8 })],
      oftType: [8, getOFTTypeSerializer()],
      ld2sdRate: [9, u64()],
      tokenMint: [17, publicKeySerializer()],
      tokenEscrow: [49, publicKeySerializer()],
      endpointProgram: [81, publicKeySerializer()],
      bump: [113, u8()],
      tvlLd: [114, u64()],
      admin: [122, publicKeySerializer()],
      defaultFeeBps: [154, u16()],
      paused: [156, bool()],
      pauser: [157, option(publicKeySerializer())],
      unpauser: [null, option(publicKeySerializer())],
    })
    .deserializeUsing<OFTStore>((account) => deserializeOFTStore(account))
    .whereField(
      'discriminator',
      new Uint8Array([195, 215, 104, 134, 185, 195, 240, 114])
    );
}
